Perfect âœ… Hereâ€™s the enhanced version of your .bat script â€” it automatically names the Excel file with todayâ€™s date (e.g. result_2025-10-29.xlsx).


---

ðŸ§¾ extract_to_excel.bat

@echo off
setlocal enabledelayedexpansion

:: === Input and output files ===
set "input=data.txt"
set "csv=data.csv"

:: === Generate date string (YYYY-MM-DD) ===
for /f "tokens=2-4 delims=/.- " %%a in ('date /t') do (
    set "day=%%a"
    set "month=%%b"
    set "year=%%c"
)
:: Handle different regional formats (if day is 2025 for example)
if "%year%"=="" (
    for /f "tokens=1-3 delims=/.- " %%a in ('date /t') do (
        set "year=%%a"
        set "month=%%b"
        set "day=%%c"
    )
)
set "today=%year%-%month%-%day%"
set "xlsx=result_%today%.xlsx"

if not exist "%input%" (
    echo Input file "%input%" not found.
    pause
    exit /b
)

echo Name,RIP,Montant > "%csv%"

:: === Read and extract fields by position ===
for /f "usebackq delims=" %%A in ("%input%") do (
    set "line=%%A"
    set "name=!line:~0,14!"
    set "rip=!line:~16,27!"
    set "montant=!line:~44,21!"

    :: Trim spaces
    for /f "tokens=* delims= " %%n in ("!name!") do set "name=%%n"
    for /f "tokens=* delims= " %%r in ("!rip!") do set "rip=%%r"
    for /f "tokens=* delims= " %%m in ("!montant!") do set "montant=%%m"

    :: Ignore if RIP is empty
    if not "!rip!"=="" (
        echo !name!,!rip!,!montant! >> "%csv%"
    )
)

echo CSV created: "%csv%"
echo Converting to Excel: "%xlsx%" ...

:: === Convert CSV to Excel (.xlsx) using PowerShell ===
powershell -command ^
    "$excel = New-Object -ComObject Excel.Application; " ^
    "$excel.Visible = $false; " ^
    "$wb = $excel.Workbooks.Open((Resolve-Path '%cd%\%csv%')); " ^
    "$wb.SaveAs((Resolve-Path '%cd%\%xlsx%'), 51); " ^
    "$wb.Close($false); " ^
    "$excel.Quit();"

echo Done! Excel file saved as "%xlsx%"
pause


---

âœ… Example output
Perfect â€” I see exactly whatâ€™s happening here ðŸ‘‡

The problem is the path contains spaces (OneDrive - BNP Paribas), and your PowerShell command doesnâ€™t quote paths correctly.
In a batch file, when passing quoted strings into PowerShell, you need escaped quotes (\") inside the PowerShell command.

Letâ€™s fix your .bat file step by step âœ…


---

âœ… Corrected Batch Script

@echo off
setlocal

:: Define file names
set "csv=data.csv"
set "xlsx=result_%date:~0,2%-%date:~3,2%-%date:~6,4%.xlsx"

echo CSV created: "%csv%"
echo Converting to Excel: "%xlsx%"

::=== Convert CSV to Excel (.xlsx) using PowerShell ===
powershell -NoProfile -Command ^
  "$excel = New-Object -ComObject Excel.Application; " ^
  "$excel.Visible = $false; " ^
  "$csvPath = Resolve-Path \"%cd%\%csv%\"; " ^
  "$xlsxPath = Join-Path (Get-Location) \"%xlsx%\"; " ^
  "$wb = $excel.Workbooks.Open($csvPath); " ^
  "$wb.SaveAs($xlsxPath, 51); " ^
  "$wb.Close($false); " ^
  "$excel.Quit();"

echo Done.
pause


---

ðŸ§  Key Fixes Explained

1. Proper PowerShell call:
powershell -NoProfile -Command is the correct syntax â€” not powershell-command.


2. Quoted paths:
I wrapped the file paths in escaped quotes (\") to handle spaces correctly ("OneDrive - BNP Paribas").


3. Using Join-Path:
Safer than Resolve-Path for non-existent output files.


4. 51 Excel format:
This is the correct code for .xlsx output (Excel Open XML Workbook).


5. Added pause:
So you can read the console output before it closes.




---

âœ… Example Output

CSV created: "data.csv"
Converting to Excel: "result_02-11-2025.xlsx"
Done.
Press any key to continue . . .


---

Would you like me to make it automatically check if Excel is installed and show a friendly message if not? (Useful for deployment.)
If today is October 29, 2025, the file will be named:

result_2025-10-29.xlsx


---

Would you like me to make it automatically delete the temporary data.csv after generating the Excel file (to keep the folder clean)?
###$$$$$$$
