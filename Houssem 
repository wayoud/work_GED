Perfect ‚úÖ Here‚Äôs the enhanced version of your .bat script ‚Äî it automatically names the Excel file with today‚Äôs date (e.g. result_2025-10-29.xlsx).


---

üßæ extract_to_excel.bat

@echo off
setlocal enabledelayedexpansion

:: === Input and output files ===
set "input=data.txt"
set "csv=data.csv"

:: === Generate date string (YYYY-MM-DD) ===
for /f "tokens=2-4 delims=/.- " %%a in ('date /t') do (
    set "day=%%a"
    set "month=%%b"
    set "year=%%c"
)
:: Handle different regional formats (if day is 2025 for example)
if "%year%"=="" (
    for /f "tokens=1-3 delims=/.- " %%a in ('date /t') do (
        set "year=%%a"
        set "month=%%b"
        set "day=%%c"
    )
)
set "today=%year%-%month%-%day%"
set "xlsx=result_%today%.xlsx"

if not exist "%input%" (
    echo Input file "%input%" not found.
    pause
    exit /b
)

echo Name,RIP,Montant > "%csv%"

:: === Read and extract fields by position ===
for /f "usebackq delims=" %%A in ("%input%") do (
    set "line=%%A"
    set "name=!line:~0,14!"
    set "rip=!line:~16,27!"
    set "montant=!line:~44,21!"

    :: Trim spaces
    for /f "tokens=* delims= " %%n in ("!name!") do set "name=%%n"
    for /f "tokens=* delims= " %%r in ("!rip!") do set "rip=%%r"
    for /f "tokens=* delims= " %%m in ("!montant!") do set "montant=%%m"

    :: Ignore if RIP is empty
    if not "!rip!"=="" (
        echo !name!,!rip!,!montant! >> "%csv%"
    )
)

echo CSV created: "%csv%"
echo Converting to Excel: "%xlsx%" ...

:: === Convert CSV to Excel (.xlsx) using PowerShell ===
powershell -command ^
    "$excel = New-Object -ComObject Excel.Application; " ^
    "$excel.Visible = $false; " ^
    "$wb = $excel.Workbooks.Open((Resolve-Path '%cd%\%csv%')); " ^
    "$wb.SaveAs((Resolve-Path '%cd%\%xlsx%'), 51); " ^
    "$wb.Close($false); " ^
    "$excel.Quit();"

echo Done! Excel file saved as "%xlsx%"
pause


---

‚úÖ Example output
Perfect ‚Äî I see exactly what‚Äôs happening here üëá

The problem is the path contains spaces (OneDrive - BNP Paribas), and your PowerShell command doesn‚Äôt quote paths correctly.
In a batch file, when passing quoted strings into PowerShell, you need escaped quotes (\") inside the PowerShell command.

Let‚Äôs fix your .bat file step by step ‚úÖ


---

‚úÖ Corrected Batch Script

@echo off
setlocal

:: Define file names
set "csv=data.csv"
set "xlsx=result_%date:~0,2%-%date:~3,2%-%date:~6,4%.xlsx"

echo CSV created: "%csv%"
echo Converting to Excel: "%xlsx%"

::=== Convert CSV to Excel (.xlsx) using PowerShell ===
powershell -NoProfile -Command ^
  "$excel = New-Object -ComObject Excel.Application; " ^
  "$excel.Visible = $false; " ^
  "$csvPath = Resolve-Path \"%cd%\%csv%\"; " ^
  "$xlsxPath = Join-Path (Get-Location) \"%xlsx%\"; " ^
  "$wb = $excel.Workbooks.Open($csvPath); " ^
  "$wb.SaveAs($xlsxPath, 51); " ^
  "$wb.Close($false); " ^
  "$excel.Quit();"

echo Done.
pause


---

üß† Key Fixes Explained

1. Proper PowerShell call:
powershell -NoProfile -Command is the correct syntax ‚Äî not powershell-command.


2. Quoted paths:
I wrapped the file paths in escaped quotes (\") to handle spaces correctly ("OneDrive - BNP Paribas").


3. Using Join-Path:
Safer than Resolve-Path for non-existent output files.


4. 51 Excel format:
This is the correct code for .xlsx output (Excel Open XML Workbook).


5. Added pause:
So you can read the console output before it closes.




---

‚úÖ Example Output

CSV created: "data.csv"
Converting to Excel: "result_02-11-2025.xlsx"
Done.
Press any key to continue . . .


---

Would you like me to make it automatically check if Excel is installed and show a friendly message if not? (Useful for deployment.)
If today is October 29, 2025, the file will be named:

result_2025-10-29.xlsx


---

Would you like me to make it automatically delete the temporary data.csv after generating the Excel file (to keep the folder clean)?
###$$$$$$
$$____
Excellent ‚Äî that‚Äôs real progress üëè
If there‚Äôs no .xlsx file generated even though the command ran without an error, it usually means Excel opened the CSV but didn‚Äôt save properly (often due to path or permissions).

Let‚Äôs fix this precisely üëá


---

‚úÖ Improved and Reliable Version

This one ensures the file is saved in the same folder as your .bat file.

@echo off
setlocal

::=== Define current directory ===
set "workdir=%~dp0"

::=== Define file names ===
set "csv=%workdir%data.csv"
set "xlsx=%workdir%result_%date:~0,2%-%date:~3,2%-%date:~6,4%.xlsx"

echo CSV created: "%csv%"
echo Converting to Excel: "%xlsx%"

::=== Convert CSV to Excel (.xlsx) using PowerShell ===
powershell -NoProfile -Command ^
  "$excel = New-Object -ComObject Excel.Application; " ^
  "$excel.Visible = $false; " ^
  "$csvPath = '%csv%'; " ^
  "$xlsxPath = '%xlsx%'; " ^
  "Write-Host 'Opening:' $csvPath; " ^
  "$wb = $excel.Workbooks.Open($csvPath); " ^
  "Write-Host 'Saving as:' $xlsxPath; " ^
  "$wb.SaveAs($xlsxPath, 51); " ^
  "$wb.Close($false); " ^
  "$excel.Quit(); " ^
  "Write-Host 'Conversion complete.'"

echo Done.
pause


---

üîç Key Improvements

%~dp0 ensures paths point to the folder containing your .bat file, not where CMD is launched from.

No Resolve-Path ‚Äî because the output file doesn‚Äôt exist yet, and that causes issues.

Debug messages show what paths Excel is actually using.



---

üß™ Test checklist

1. Put your .bat file and data.csv in the same folder.


2. Run the .bat file by double-clicking it (not from a different path).


3. Watch the PowerShell output ‚Äî you should see:

Opening: C:\Users\h34667\OneDrive - BNP Paribas\Documents\test\data.csv
Saving as: C:\Users\h34667\OneDrive - BNP Paribas\Documents\test\result_02-11-2025.xlsx
Conversion complete.


4. After it says Done, check the same folder for your .xlsx.




---

If it still doesn‚Äôt appear, please tell me what the PowerShell lines say (those that start with ‚ÄúOpening:‚Äù and ‚ÄúSaving as:‚Äù), and I‚Äôll pinpoint the exact cause.

Would you like me to make it overwrite the file automatically if it already exists (instead of Excel prompting silently)?
